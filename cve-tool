#!/usr/bin/env perl

use v5.34;
use experimental qw(signatures try);
use strict;
use Getopt::Long;
use Text::SimpleTable;
use Mojo::JSON qw(decode_json);
use Mojo::File qw(path);
use Mojo::Util qw(encode trim);
use Mojo::Date;

my $opt_repo_path   = path($ENV{HOME}, ".local/share/cvelistV5") . "";
my $opt_repo_url    = "https://github.com/CVEProject/cvelistV5";

sub usage {
  return <<"EOT";
Usage: $0
    --initialize    Clone cvelistV5 repo
    --update        Pull latest updates

    --search        Limit results to descriptions matching regexp
    --days-back     Number or days to limit results to

    --reverse       Reverse order
    --fancy         Use fancy formatting

    --repo-path     Local path to repo
                    default: $opt_repo_path
    --repo-url      Path to remote git repo
                    default: $opt_repo_url
EOT

}


GetOptions("initialize"      => \my $opt_initialize,
           "update"          => \my $opt_update,
           "repo-path=s"     => \$opt_repo_path,
           "repo-git-url=s"  => \$opt_repo_url,
           "num=i"           => \my $opt_num,
           "search=s"        => \my $opt_search,
           "days-back=i"     => \my $opt_days_back,
           "h|help"          => \my $opt_help,
           "r|reverse"       => \my $opt_reverse,
           "fancy"           => \my $opt_fancy,
           "verbose"         => \my $verbose) || err("Error in command line arguments");

main();

sub main {
  return help()       if $opt_help;

  return initialize($opt_repo_path, $opt_repo_url) if $opt_initialize;

  my $repo = path($opt_repo_path);

  err("repo=$repo does not exist, initialize it with --initialize or specify your own with --repo-path")
    unless -d $repo;

  err("repo=$repo does not contain expected cves/deltaLog.json file")
    unless -f $repo->child("cves/deltaLog.json");

  err("repo=$repo is not a git repository")
    unless -d $repo->child(".git");

  update($repo) if $opt_update;

  my $latest_delta = latest_delta($repo);

  my $until;
  if ($opt_days_back) {
    ($until) = Mojo::Date->new(time()-($opt_days_back*86400))->to_datetime =~ m/^(\d{4}-\d{2}-\d{2})/;
  }

  my @table;
  LOOP: foreach my $delta ($latest_delta->@*) {
    my ($date) = $delta->{fetchTime} =~ m/^(\d{4}-\d{2}-\d{2})/;
    if ($until) {
      last if $date lt $until;
    }
    foreach my $section (qw(new updated)) {
      UPDATE: foreach ($delta->{$section}->@*) {
        my $cve = cve($_->{cveId}, $repo);
        my $desc = cve_description($cve);
        if ($opt_search) {
          next UPDATE unless $desc =~ m/$opt_search/i;
        }

        (my $desc_short = $desc) =~ s/\s+/ /gsm;
        $desc_short = trim($desc_short);
        if (length($desc_short)>=90) {
          $desc_short = substr($desc_short,0,87)."...";
        }


        push @table, { date => $date,
                       section => $section,
                       id => $_->{cveId},
                       desc => $desc,
                       desc_short =>  $desc_short};
      }
    }
  }

  if ($opt_reverse) {
    @table = reverse @table;
  }

  if ($opt_fancy) {
    my $table = Text::SimpleTable->new(10, 7, 15, 90);
    my $i=0;
    foreach (@table) {
      $table->hr if $i++;
      $table->row($_->{date}, $_->{section}, $_->{id}, $_->{desc});
    }
    say $table->boxes->draw;
  } else {
    foreach my $row (@table) {
      printf("%-10s %-7s %-15s %90s\n", $_->{date}, $_->{section}, $_->{id}, $_->{desc_short}) foreach @table;
    }
  }

}

sub initialize ($path, $url) {
  err("$path already exists, cannot initialize") if -d $path;
  say "Cloning $url, this is a large repo and can take a while";
  system("git", "clone", $url, $path);
}

sub update ($repo) {
  say "Updating $repo ...";
  system("git", "--work-tree=$repo", "--git-dir=$repo/.git", "pull");
}


sub help { say usage() };

sub err ($msg) {
  die "ERROR: $msg\n".usage();
}

sub chat($msg) {
  print STDERR "[".localtime()."] $msg\n" if $verbose;
}

sub cve_description($data) {
  my $cd = $data->{containers}->{cna}->{descriptions};
  my ($desc) = map { $_->{value} } grep { $_->{lang} eq 'en'} $cd->@*;
  return encode 'UTF-8', ($desc // "");
}

sub latest_delta ($repo) {
  return decode_json($repo->child("cves/deltaLog.json")->slurp);
}

sub cve ($id, $repo) {
  my ($year, $seq) = $id =~ m/^CVE-(\d{4})-(\d{4,})$/;
  die "invalid cve: $id" unless $year && $seq;
  my ($subdir_prefix) = $seq =~ /^(\d+)\d{3}$/;
  my $path = path($repo)->child("cves/${year}/${subdir_prefix}xxx/${id}.json");

  return decode_json( $path->slurp );
}
